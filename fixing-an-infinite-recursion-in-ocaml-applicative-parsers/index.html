<!doctype html><html lang=en-us><head><title>Fixing an infinite recursion in OCaml applicative parsers // A fractal spectrum of tales</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.139.4"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Marcello Seri"><meta name=description content="Free thoughts of a geeky mathematician"><meta http-equiv=Permissions-Policy content="interest-cohort=()"><link rel=stylesheet href=https://www.mseri.me/css/main.min.fb6dd6e5b8f0b7c4a9008884f1a95d7a84ef20fb9c190bcbbd87b6ff85f8fb9b.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Fixing an infinite recursion in OCaml applicative parsers"><meta name=twitter:description content="Nine years ago, while I was still a fresh OCamlr, I gave a presentation (later turned blog post) with title First steps with Category Theory and OCaml. The idea was to show how to implement the basic typeclasses of Category Theory in OCaml, and how to use them to build a simple parser combinator library, by following what I had learned from Haskell. At the time, not knowing better, I stumbled upon an annoying issue: if you look at the code examples for the Alternative_Utils module, you will find the following commented-out code."><meta property="og:url" content="https://www.mseri.me/fixing-an-infinite-recursion-in-ocaml-applicative-parsers/"><meta property="og:site_name" content="A fractal spectrum of tales"><meta property="og:title" content="Fixing an infinite recursion in OCaml applicative parsers"><meta property="og:description" content="Nine years ago, while I was still a fresh OCamlr, I gave a presentation (later turned blog post) with title First steps with Category Theory and OCaml. The idea was to show how to implement the basic typeclasses of Category Theory in OCaml, and how to use them to build a simple parser combinator library, by following what I had learned from Haskell. At the time, not knowing better, I stumbled upon an annoying issue: if you look at the code examples for the Alternative_Utils module, you will find the following commented-out code."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-27T11:33:16+01:00"><meta property="article:modified_time" content="2026-02-27T11:33:16+01:00"><meta property="article:tag" content="Ocaml"><meta property="article:tag" content="Parser Combinators"><meta property="article:tag" content="Category Theory"><meta property="article:tag" content="Monad"><meta property="article:tag" content="Functor"><meta property="article:tag" content="Applicative"></head><body><header class=app-header><a href=https://www.mseri.me/><img class=app-header-avatar src=/images/gauss_logo.png alt="Marcello Seri"></a><h1>A fractal spectrum of tales</h1><p>Free thoughts of a geeky mathematician</p><div class=app-header-social><a target=_blank href=https://github.com/mseri rel="noreferrer noopener me"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a>
<a target=_blank href=https://mathstodon.xyz/@mseri rel="noreferrer noopener me"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-mastodon"><title>mastodon</title><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M18.648 15.254C16.832 17.017 12 16.88 12 16.88a18.262 18.262.0 01-3.288-.256c1.127 1.985 4.12 2.81 8.982 2.475-1.945 2.013-13.598 5.257-13.668-7.636L4 10.309c0-3.036.023-4.115 1.352-5.633C7.023 2.766 12 3.01 12 3.01s4.977-.243 6.648 1.667C19.977 6.195 20 7.274 20 10.31s-.456 4.074-1.352 4.944z"/><path d="M12 11.204V8.278C12 7.02 11.105 6 10 6S8 7.02 8 8.278V13m4-4.722C12 7.02 12.895 6 14 6s2 1.02 2 2.278V13"/></svg></a>
<a target=_blank href=https://bsky.app/profile/mseri.me rel="noreferrer noopener me"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a>
<a target=_blank href=https://academic.mseri.me rel="noreferrer noopener me"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-award"><title>award</title><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></svg></a></div><div style=margin-top:30px><h3 style=margin-bottom:10px>My podcasts</h4><a href=https://podcasters.spotify.com/pod/show/not-just-numbers><img src=/images/njn.jpg alt="Cover of the pocast it's not just numbers" class=image width=105px>
</a>&nbsp;
<a href=https://linktr.ee/degreesoffreedom><img src=/images/dof.jpg alt="Cover of the podcast degrees of freedom" class=image width=105px></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Fixing an infinite recursion in OCaml applicative parsers</h1><div class=post-meta><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
Feb 27, 2026</div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
22 min read</div><div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a class=tag href=https://www.mseri.me/tags/ocaml/>Ocaml</a><a class=tag href=https://www.mseri.me/tags/parser-combinators/>Parser Combinators</a><a class=tag href=https://www.mseri.me/tags/category-theory/>Category Theory</a><a class=tag href=https://www.mseri.me/tags/monad/>Monad</a><a class=tag href=https://www.mseri.me/tags/functor/>Functor</a><a class=tag href=https://www.mseri.me/tags/applicative/>Applicative</a><a class=tag href=https://www.mseri.me/tags/typeclass/>Typeclass</a></div></div></header><aside><hr style=margin-top:1.5em><h3 id=TableOfContents>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#a-delay-done-right-deferring-eager-evaluation>A <code>delay</code> done right: deferring eager evaluation</a></li><li><a href=#a-concrete-example-parsing-s-expressions>A concrete example: parsing S-Expressions</a></li><li><a href=#a-more-realistic-sexp-example-parsing-simple-dune-files>A more realistic <code>sexp</code> example: parsing simple <code>dune</code> files</a></li><li><a href=#the-complete-code>The complete code</a></li></ul></nav><hr></aside><div class=post-content><p>Nine years ago, while I was still a fresh OCamlr, I gave a presentation (later turned blog post) with title <a href=https://www.mseri.me/typeclass-ocaml/>First steps with Category Theory and OCaml</a>.
The idea was to show how to implement the basic typeclasses of Category Theory in OCaml, and how to use them to build a simple parser combinator library, by following what I had learned from Haskell.
At the time, not knowing better, I stumbled upon an annoying issue: if you look at the code examples for the <code>Alternative_Utils</code> module, you will find the following commented-out code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>  <span style=color:#75715e>(*
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (* This should not be a comment, but for some reason ocaml 4.03 is optimising
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * the hell out of it and it ends up in a stack overflow due to infinite recursion.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * I have also tried in vane to use lazy, with the same result. They do work, however,
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * when implemented separately case by case. *)
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (* note the need to break infinite recursion adding an intermediate evaluation *)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  let delay f = f ()
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (** Zero or more *)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (* it could be defined as some v with `in some_ v` replaced by `in many_ v` *)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  let rec many p = List.cons &lt;$&gt; p &lt;*&gt; (delay @@ fun _ -&gt; many p)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &lt;|&gt; pure[]
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>  (** One or more *)
</span></span></span><span style=display:flex><span><span style=color:#75715e>  let some v = let rec some_ v = List.cons &lt;$&gt; v &lt;*&gt; (delay @@ fun _ -&gt; many_ v)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    and many_ v = some_ v &lt;|&gt; pure[]
</span></span></span><span style=display:flex><span><span style=color:#75715e>    in some_ v
</span></span></span><span style=display:flex><span><span style=color:#75715e>  *)</span>
</span></span></code></pre></div><p>As you can read, my reaction was to blame the compiler. Of course, I was wrong :)</p><p>It took some months before I understood what I was doing wrong and I never found the time to update that post.
During a recent train trip, however, when I was simply too tired to work more and I was mindlessly staring out the window, this just came back to mind and I decided to give it another go.</p><p>As it turns out, OCaml wasn&rsquo;t maliciously optimizing my code into a stack overflow.
As an eager language (and in contrast to lazy ones, like Haskell), it was just doing its job.
But we <em>can</em> make sure it does what we want and it is not so hard!</p><p>Note that from now on, I will be assuming that you have read the <a href=https://www.mseri.me/typeclass-ocaml/>old post</a>.
Most of the combinators I will be using below come from there and I will not re-explain them.</p><h2 id=a-delay-done-right-deferring-eager-evaluation><a class=hanchor href=#a-delay-done-right-deferring-eager-evaluation>#</a>&nbsp;A <code>delay</code> done right: deferring eager evaluation</h2><p>In a language like OCaml, arguments to functions (and combinators like <code>&lt;*></code> and <code>&lt;|></code>) are evaluated <em>before</em> the function itself is executed.
To construct the parser <code>many p</code>, OCaml must first evaluate the right-hand side of the <code>&lt;*></code> operator: <code>delay (fun _ -> many p)</code>.</p><p>Since <code>delay</code> was defined as <code>let delay f = f ()</code>, the function <code>f</code> is executed immediately.
This immediately calls <code>many p</code>, which evaluates <code>delay</code>, which calls <code>many p</code>&mldr; and so on.
Taking a moment to think about it, makes it clear that we will get a <code>Stack_overflow</code> already during the construction of the parser, long before we even feed it a string to parse!</p><p>In a lazy language like Haskell, this isn&rsquo;t an issue because <code>many p</code> wouldn&rsquo;t be forced until it&rsquo;s actually consumed by the parser input.
To fix this in OCaml, we need to be smarter in our use of <code>delay</code> to defer the evaluation.</p><p>In the original attempt, I was trying to hide <code>delay</code> inside <code>Alternative_Utils</code>.
But since the type <code>'a t</code> is completely abstract there, we cannot access the data structure itself to manually defer the evaluation.
In other words, we can only define behaviors that rely on the existing abstract operators, like <code>&lt;*></code>, <code>fmap</code>, <code>&lt;|></code>.</p><p>To solve this, let&rsquo;s just make the concept of deferred evaluation explicit and expose it directly into the <code>ALTERNATIVE</code> signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ALTERNATIVE</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>APPLICATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> empty<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(&lt;|&gt;):</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Defers evaluation to avoid infinite recursion*)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> delay<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Now that the module type enforces the <code>delay</code> primitive, our <code>Alternative_Utils</code> implementation can directly (and abstractly) make use of it.
We can write <code>many</code> and <code>some</code> identically to their mathematical definitions by wrapping the recursive branch in <code>A.delay</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Alternative_Utils</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ALTERNATIVE</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>AppU</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Applicative_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>AppU</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Zero or more *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> many p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    A.delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> some p <span style=color:#f92672>&lt;|&gt;</span> pure[]<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** One or more *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>and</span> some p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.cons <span style=color:#f92672>&lt;$&gt;</span> p <span style=color:#f92672>&lt;*&gt;</span> many p
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Notice how <code>many</code> and <code>some</code> are mutually recursive.
When <code>some p</code> constructs its parser, it requests <code>many p</code>.
But because <code>many p</code> immediately returns <code>A.delay (...)</code> this is not a problem.
The fact that <code>delay</code> wraps the whole parser (and is not simply within an argument, like in the original broken implementation) makes sure the recursion stops instantly until an evaluation is requested: the actual parser chain isn&rsquo;t built until the <code>delay</code> is forced!
And indeed, you can paste the code in <code>utop</code> and it will happily define everything without a stack overflow.</p><p>The remaining question, now, is: does this work in practice?</p><p>We can get back the <a href=https://www.mseri.me/typeclass-ocaml/#a-practical-example---monadic-parsing-library>old parser code</a> and see what an implementation now looks like.</p><p>Implementing <code>delay</code> properly is beautifully elegant, thanks to a functional trick called <em>eta-expansion</em>: we just need to explicitly present the argument to the function!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>ParserAlternative</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>ALTERNATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a p<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>ParserApplicative</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> empty <span style=color:#f92672>_</span> <span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;|&gt;)</span> p1 p2 txt <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> p1 txt <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> []  <span style=color:#f92672>-&gt;</span> p2 txt
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> res <span style=color:#f92672>-&gt;</span> res
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Eta-expansion saves the day! *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> delay f <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> input <span style=color:#f92672>-&gt;</span> f () input
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Because OCaml is strict, eta-expansion changes the order of evaluation.
In this way, <code>many</code> and <code>some</code> work universally without crashing the stack, and we can use them to parse recursive structures.</p><p>This construction is a nice example also to get into some more technical computer sciency terminology.</p><p>The term eta-expansion originates from <a href=https://en.wikipedia.org/wiki/Lambda_calculus>lambda calculus</a> (quite a fun topic if you are mathematically inclined), where it denotes a way to convert an expression like $f$ into $x \mapsto f(x)$, effectively wrapping the function to accept parameters explicitly.
The opposite is achieved by <em>eta-reduction</em>, which simplifies $x \mapsto f(x)$ to just $f$ (when they are equivalent).</p><p>Back to our example, by explicitly taking the <code>input</code> list and passing it to the function, we create a so-called <em>closure</em>: this is a function bundled together with its surrounding environment.
In a sense, it remembers and retains access to variables from its enclosing (lexical) scope even after such scope has finished executing.
Then <code>f ()</code> is safely suspended and won&rsquo;t be evaluated until the string input begins flowing through the parser.
If you are familiar with Haskell, now <code>f ()</code> is a thunk awaiting evaluation.</p><p>I won&rsquo;t spend more time on this here, eta-expansion can be a <a href=https://ocaml.org/manual/5.2/polymorphism.html#ss:valuerestriction>useful</a> <a href=https://stackoverflow.com/questions/25763412/why-does-ocaml-sometimes-require-eta-expansion>pattern</a> in OCaml.</p><h2 id=a-concrete-example-parsing-s-expressions><a class=hanchor href=#a-concrete-example-parsing-s-expressions>#</a>&nbsp;A concrete example: parsing S-Expressions</h2><p>Let&rsquo;s make this more concrete and build a parser for <a href=https://en.wikipedia.org/wiki/Lisp_(programming_language)#Syntax_and_semantics>lisp</a>-style S-expressions (<code>sexp</code> from now on).
For a brief introduction have a look at <a href=https://uwplse.org/2025/12/09/S-expressions.html>this blog post</a> or <a href=https://dev.realworldocaml.org/data-serialization.html>real world ocaml</a>.</p><p>For what concerns us, a <code>sexp</code> is either</p><ul><li>an <strong>atom</strong>, i.e. a string for any practical purpose,</li><li>a <strong>list</strong>, i.e. a sequence of <code>sexp</code>s.</li></ul><p>To be more precise, the lists are usually delimited by parentheses (<code>(</code>, <code>)</code>) and the elements are separated by whitespaces. The atoms are space delimited strings of alphanumeric symbols.
For instance, <code>(= (+ 1 1) 2)</code> is a <code>sexp</code> that a lisp interpreter would evaluate to true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>CP</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MakeCharParser</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Parser</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Parser</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>open</span> <span style=color:#a6e22e>CP</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> sexp <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Atom</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Lst</span> <span style=color:#66d9ef>of</span> sexp <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> string_of_chars <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span>String.make 1<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;.&gt;</span> String.concat <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> spaces <span style=color:#f92672>=</span> many space
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> atom <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> chars <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span>string_of_chars chars<span style=color:#f92672>))</span> <span style=color:#f92672>&lt;$&gt;</span> some alpha_num
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* S-expressions are inherently recursive, so we also wrap them in a `delay`! *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> sexp () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list_parser <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> elements <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Lst</span> elements<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;(&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;)&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    atom <span style=color:#f92672>&lt;|&gt;</span> list_parser
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> sexp_parser <span style=color:#f92672>=</span> spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces
</span></span></code></pre></div><p>If we run this in <code>utop</code> using our standard <code>run</code> function, we get exactly what we expect:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#f92672>#</span> run sexp_parser <span style=color:#e6db74>&#34;(foo (bar 123) baz)&#34;</span><span style=color:#f92672>;;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>-</span> <span style=color:#f92672>:</span> sexp <span style=color:#66d9ef>list</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span><span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;bar&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;123&#34;</span><span style=color:#f92672>];</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;baz&#34;</span><span style=color:#f92672>]]</span>
</span></span></code></pre></div><p>Note that all helpers were completely general! By properly encoding the deferred evaluation into our implementation, we got the same elegant parser combinators you would expect from a purely functional language like Haskell.</p><p>It may seem a completely pointless exercise, but what we are seeing as the result of running the parser, is an Abstract Syntax Tree (AST).
This is a core concept in computer science, central to build for example compilers or to make structured sense of information.
Say that you use Wolfram Mathematica to compute integrals.
You might to something like</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Mathematica data-lang=Mathematica><span style=display:flex><span>In[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>:=</span> sint[b_] <span style=color:#f92672>:=</span> Integrate[Sin[x], {x, <span style=color:#ae81ff>0</span>, b}]
</span></span><span style=display:flex><span>In[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>:=</span> sint[b]
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> Cos[b]
</span></span><span style=display:flex><span>In[<span style=color:#ae81ff>3</span>]<span style=color:#f92672>:=</span> sint[Pi]
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>3</span>]<span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>Within Mathematica, however, these expressions are parsed into an AST which is then manipulated and perhaps simplified. You can look at it with the <code>FullForm</code> command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Mathematica data-lang=Mathematica><span style=display:flex><span>In[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>:=</span> sint[b] <span style=color:#f92672>//</span> FullForm
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>//</span>FullForm<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    Plus[<span style=color:#ae81ff>1</span>,Times[<span style=color:#ae81ff>-1</span>,Cos[b]]]
</span></span><span style=display:flex><span>In[<span style=color:#ae81ff>5</span>]<span style=color:#f92672>:=</span> sint[Pi] <span style=color:#f92672>//</span> FullForm
</span></span><span style=display:flex><span>Out[<span style=color:#ae81ff>5</span>]<span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>In fact, the displayed text is itself an AST specifying the text that should be displayed. Copy-pasting it to a text editor would show:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Mathematica data-lang=Mathematica><span style=display:flex><span>Out[<span style=color:#ae81ff>4</span>]<span style=color:#f92672>//</span>FullForm<span style=color:#f92672>=</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>!</span><span style=color:#960050;background-color:#1e0010>\</span>(
</span></span><span style=display:flex><span>TagBox[
</span></span><span style=display:flex><span>StyleBox[
</span></span><span style=display:flex><span>RowBox[{<span style=color:#e6db74>&#34;Plus&#34;</span>, <span style=color:#e6db74>&#34;[&#34;</span>, 
</span></span><span style=display:flex><span>RowBox[{<span style=color:#e6db74>&#34;1&#34;</span>, <span style=color:#e6db74>&#34;,&#34;</span>, 
</span></span><span style=display:flex><span>RowBox[{<span style=color:#e6db74>&#34;Times&#34;</span>, <span style=color:#e6db74>&#34;[&#34;</span>, 
</span></span><span style=display:flex><span>RowBox[{
</span></span><span style=display:flex><span>RowBox[{<span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;1&#34;</span>}], <span style=color:#e6db74>&#34;,&#34;</span>, 
</span></span><span style=display:flex><span>RowBox[{<span style=color:#e6db74>&#34;Cos&#34;</span>, <span style=color:#e6db74>&#34;[&#34;</span>, <span style=color:#e6db74>&#34;b&#34;</span>, <span style=color:#e6db74>&#34;]&#34;</span>}]}], <span style=color:#e6db74>&#34;]&#34;</span>}]}], <span style=color:#e6db74>&#34;]&#34;</span>}],
</span></span><span style=display:flex><span>ShowSpecialCharacters<span style=color:#f92672>-&gt;</span>False,
</span></span><span style=display:flex><span>ShowStringCharacters<span style=color:#f92672>-&gt;</span>True,
</span></span><span style=display:flex><span>NumberMarks<span style=color:#f92672>-&gt;</span>True],
</span></span><span style=display:flex><span>FullForm]<span style=color:#960050;background-color:#1e0010>\</span>)
</span></span></code></pre></div><p>But enough with this detour, let&rsquo;s look at a more realistic example!</p><h2 id=a-more-realistic-sexp-example-parsing-simple-dune-files><a class=hanchor href=#a-more-realistic-sexp-example-parsing-simple-dune-files>#</a>&nbsp;A more realistic <code>sexp</code> example: parsing simple <code>dune</code> files</h2><p>Let&rsquo;s test our parser on a real-world configuration file, we can parse a <code>dune</code> build file.
For instance we will update the parser to be able to parse <a href=https://github.com/mseri/doi2bib>doi2bib</a>&rsquo;s dune file.</p><p>To make this work, we only need to slightly upgrade our parser.
Real-world S-expressions, like those used by Dune, need to handle a few extra things.
For our specific purpose it will be enough to make two changes:</p><ol><li><p>We should allow some special characters in atoms, like <code>-</code>, <code>_</code>, <code>.</code>, <code>/</code>, and <code>:</code>, and</p></li><li><p>We should allow the presence of multiple <code>sexp</code>s: a dune file is a sequence of several S-expressions separated by whitespace.</p></li></ol><p>At this point though, extending our parser is not such a big deal.</p><p>As we just mentioned, we first need to allow for an extended list of symbols, for instance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> symbol_char <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>  alpha_num <span style=color:#f92672>&lt;|&gt;</span> one_of<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;_&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;-&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;.&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;/&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;:&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;*&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;+&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;=&#39;</span><span style=color:#f92672>]</span>
</span></span></code></pre></div><p>With that, we can extend our definition of atoms and add quoted strings, which are also extensively used in dune files:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> atom <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> chars <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span>string_of_chars chars<span style=color:#f92672>))</span> <span style=color:#f92672>&lt;$&gt;</span> some symbol_char
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> quoted_string <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> chars <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>^</span> string_of_chars chars <span style=color:#f92672>^</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;&#34;&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>none_of <span style=color:#f92672>[</span><span style=color:#e6db74>&#39;&#34;&#39;</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;&#34;&#39;</span>
</span></span></code></pre></div><p>With those two helpers at hand, the parser is practically the same as before:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> sexp () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> list_parser <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>      <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> elements <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Lst</span> elements<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;(&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;)&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    atom <span style=color:#f92672>&lt;|&gt;</span> quoted_string <span style=color:#f92672>&lt;|&gt;</span> list_parser
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span>
</span></span></code></pre></div><p>We only need to remember that a dune file is just a sequence of S-expressions, so we need to wrap the whole thing in <code>many</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> dune_file_parser <span style=color:#f92672>=</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Now, take the dune file to build the <code>doi2bib</code> executable, namely</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> doi2bib_dune_content <span style=color:#f92672>=</span> <span style=color:#f92672>{|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>executable
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>name doi2bib<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>public_name doi2bib<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>libraries lwt lwt<span style=color:#f92672>.</span>unix cohttp<span style=color:#f92672>-</span>lwt<span style=color:#f92672>-</span>unix ezjsonm lambdasoup re cmdliner<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>flags <span style=color:#f92672>(:</span>standard <span style=color:#f92672>-</span>w <span style=color:#f92672>-</span>40<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>rule
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>targets doi2bib<span style=color:#f92672>.</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>deps doi2bib<span style=color:#f92672>.</span>exe<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>action <span style=color:#f92672>(</span>run <span style=color:#f92672>./</span>doi2bib<span style=color:#f92672>.</span>exe <span style=color:#f92672>--</span>help<span style=color:#f92672>=</span>groff<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|}</span>
</span></span></code></pre></div><p>and run the parser on it with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> parsed_dune <span style=color:#f92672>=</span> run dune_file_parser doi2bib_dune_content
</span></span></code></pre></div><p>If you run this in <code>utop</code>, the output will confirm that our eager evaluation issue is completely solved and the parser navigates the depth of the configuration file to produce a clean AST:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>val</span> parsed_dune <span style=color:#f92672>:</span> sexp <span style=color:#66d9ef>list</span> <span style=color:#66d9ef>list</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>[[</span><span style=color:#a6e22e>Lst</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;executable&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;doi2bib&#34;</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;public_name&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;doi2bib&#34;</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Lst</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;libraries&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;lwt&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;lwt.unix&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;cohttp-lwt-unix&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;ezjsonm&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;lambdasoup&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;re&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;cmdliner&#34;</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;flags&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;:standard&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;-w&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;-40&#34;</span><span style=color:#f92672>]]];</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Lst</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;rule&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;targets&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;doi2bib.1&#34;</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;deps&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;doi2bib.exe&#34;</span><span style=color:#f92672>];</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>Lst</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;action&#34;</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Lst</span> <span style=color:#f92672>[</span><span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;run&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;./doi2bib.exe&#34;</span><span style=color:#f92672>;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#e6db74>&#34;--help=groff&#34;</span><span style=color:#f92672>]]]]]</span>
</span></span></code></pre></div><p>Note how the outer list has exactly one element containing our two parsed root nodes. This is because our parser combinator correctly consumes the entire input as a single successful parse operation!</p><p>There we have it: a fully functional, recursive Applicative parser in OCaml, driven purely by Category Theory typeclasses.
Of course, for real world use I would never recommend to use this parser.
We already have pretty solid libraries like <a href=https://github.com/ocaml-dune/csexp><code>csexp</code></a> or <a href=https://github.com/janestreet/sexplib><code>sexplib</code></a> that are well tested and have been used in production for years.
Similarly, if you want to write a lisp interpreter, you will need to integrate more information in the parser, like distinguishing different numerical types, quoting and unquoting <code>sexp</code> expressions, support for the basic keywords, &mldr;
But for a blog post, I think we pushed it quite a long way.</p><h2 id=the-complete-code><a class=hanchor href=#the-complete-code>#</a>&nbsp;The complete code</h2><p>To try it out, you can run the code below, it also includes the code from the previous blog post with the most relevant comments preserved.</p><p>Different parts of the code are separated into sections, so that you can copy-paste them independently, and the code is more modularized so that you can play around with it without polluting the namespace too much.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Basic helpers
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> id x <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> const x <span style=color:#f92672>_</span> <span style=color:#f92672>=</span> x
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> flip f x y <span style=color:#f92672>=</span> f y x
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> compose f g x <span style=color:#f92672>=</span> f <span style=color:#f92672>(</span>g x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;.&gt;)</span> f g <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> f <span style=color:#f92672>(</span>g x<span style=color:#f92672>)</span> <span style=color:#75715e>(* &lt;- compose *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>(&gt;.&gt;)</span> g f <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> f <span style=color:#f92672>(</span>g x<span style=color:#f92672>)</span> <span style=color:#75715e>(* first apply [g] then [f] but writing them the other way around *)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Main module types
</span></span></span><span style=display:flex><span><span style=color:#75715e>   and the utilities that we can abstractly construct from them
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MONOID</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Monoid *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Neutral element *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> mempty <span style=color:#f92672>:</span> t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Associative operation *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> mappend<span style=color:#f92672>:</span> t <span style=color:#f92672>-&gt;</span> t <span style=color:#f92672>-&gt;</span> t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Monoid_Utils</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>M</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>MONOID</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Generic Monoid helpers *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>M</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** A convenient shorthand for mappend *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;+&gt;)</span> x y <span style=color:#f92672>=</span> mappend x y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Any monoid can be concatenated *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> concat xs <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(&lt;+&gt;)</span> mempty xs
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>FUNCTOR</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> fmap<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Functor_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>F</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>FUNCTOR</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Generic Functor helpers *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>F</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** A convenient shorthand for fmap *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;$&gt;)</span> f x <span style=color:#f92672>=</span> fmap f x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Replace all locations in the input with the same value *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;$)</span> r x <span style=color:#f92672>=</span> fmap <span style=color:#f92672>(</span>const r<span style=color:#f92672>)</span> x
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Flipped version of &lt;$ *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>($&gt;)</span> r x <span style=color:#f92672>=</span> flip <span style=color:#f92672>(&lt;$)</span> r x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** [void] discards or ignores the result of evaluation *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> void f x <span style=color:#f92672>=</span> fmap <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> ignore<span style=color:#f92672>(</span>f x<span style=color:#f92672>))</span> x
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>APPLICATIVE</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* This includes the signature of FUNCTOR,
</span></span></span><span style=display:flex><span><span style=color:#75715e>     rewriting the types to make them match *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>FUNCTOR</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Lift a value *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> pure<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Sequential application *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> ap<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Note that if you still have to define the functor,
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * you can define `fmap` from the above functions as
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * `let fmap f x = pure f &lt;*&gt; x` *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Applicative_Utils</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>APPLICATIVE</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Generic Functor helpers *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>FunU</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Functor_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>FunU</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** A convenient infix for ap -- called apply*)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;*&gt;)</span> f <span style=color:#f92672>=</span> ap f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Below, we denote `actions` the elements of the applicative typeclass *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Lift a function to actions. This function may be used as a value
</span></span></span><span style=display:flex><span><span style=color:#75715e>      for fmap in a Functor instance. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> liftA f x <span style=color:#f92672>=</span> f <span style=color:#f92672>&lt;$&gt;</span> x
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Lift a binary function to actions. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> liftA2 f x y  <span style=color:#f92672>=</span> f <span style=color:#f92672>&lt;$&gt;</span> x <span style=color:#f92672>&lt;*&gt;</span> y
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Lift a ternary function to actions. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> liftA3 f x y z <span style=color:#f92672>=</span> f <span style=color:#f92672>&lt;$&gt;</span> x <span style=color:#f92672>&lt;*&gt;</span> y <span style=color:#f92672>&lt;*&gt;</span> z
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Sequence actions, discarding the value of the second argument. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span> <span style=color:#f92672>&lt;*</span> <span style=color:#f92672>)</span> r x <span style=color:#f92672>=</span> const <span style=color:#f92672>&lt;$&gt;</span> r <span style=color:#f92672>&lt;*&gt;</span> x
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Sequence actions, discarding the value of the first argument. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span> <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>)</span> r x <span style=color:#f92672>=</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> y <span style=color:#f92672>-&gt;</span> y<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;$&gt;</span> r <span style=color:#f92672>&lt;*&gt;</span> x     <span style=color:#75715e>(* == flip ( &lt;* ) *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Evaluate each action in the structure from left to right, and
</span></span></span><span style=display:flex><span><span style=color:#75715e>      and collect the results. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> sequenceA <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> pure []
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> x <span style=color:#f92672>::</span> xs <span style=color:#f92672>-&gt;</span> List.cons <span style=color:#f92672>&lt;$&gt;</span> x <span style=color:#f92672>&lt;*&gt;</span> sequenceA xs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Evaluate each action in the structure from left to right, and
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *  ignore the results *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sequenceA_ xs <span style=color:#f92672>=</span> List.fold_right <span style=color:#f92672>(</span> <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>)</span> xs <span style=color:#f92672>(</span>pure ()<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Map each element of a structure to an action, evaluate these actions
</span></span></span><span style=display:flex><span><span style=color:#75715e>      from left to right, and collect the results. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> traverseA f <span style=color:#f92672>=</span>  <span style=color:#f92672>(</span>List.map f<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;.&gt;</span> sequenceA
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Map each element of a structure to an action, evaluate these
</span></span></span><span style=display:flex><span><span style=color:#75715e>      actions from left to right, and ignore the results. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> traverseA_ f xs <span style=color:#f92672>=</span> List.fold_right <span style=color:#f92672>((</span> <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>)</span> <span style=color:#f92672>&lt;.&gt;</span> f<span style=color:#f92672>)</span> xs <span style=color:#f92672>(</span>pure ()<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** `forA` is &#39;traverse&#39; with its arguments flipped. *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> forA xs <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>flip traverseA<span style=color:#f92672>)</span> xs
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ALTERNATIVE</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>APPLICATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>:=</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** The identity of &lt;|&gt; *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> empty<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** An associative binary operation -- practically mappend *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(&lt;|&gt;):</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Our new addition to break infinite recursion by deferring evaluation *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> delay<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GENERIC_TYPE_WORKAROUND</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span> <span style=color:#66d9ef>type</span> t <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Alternative_Utils</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>ALTERNATIVE</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Generic Alternative helpers *)</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>A</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>AppU</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Applicative_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>A</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>AppU</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>AltMonoid</span><span style=color:#f92672>(</span><span style=color:#a6e22e>T</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>GENERIC_TYPE_WORKAROUND</span><span style=color:#f92672>):</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>MONOID</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> T.t A.t<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> T.t A.t
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mempty <span style=color:#f92672>=</span> A.empty
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> mappend <span style=color:#f92672>=</span> A.<span style=color:#f92672>(&lt;|&gt;)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Zero or more *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> many p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    A.delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> some p <span style=color:#f92672>&lt;|&gt;</span> pure[]<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** One or more *)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>and</span> some p <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.cons <span style=color:#f92672>&lt;$&gt;</span> p <span style=color:#f92672>&lt;*&gt;</span> many p
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Always return empty *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> fail <span style=color:#f92672>=</span> empty
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(** Another name for concat *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> choose <span style=color:#f92672>(</span><span style=color:#66d9ef>type</span> a<span style=color:#f92672>)</span> ps <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>AM</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Monoid_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>AltMonoid</span><span style=color:#f92672>(</span><span style=color:#66d9ef>struct</span> <span style=color:#66d9ef>type</span> t <span style=color:#f92672>=</span> a <span style=color:#66d9ef>end</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> AM.concat ps
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>We have not discussed this specific example in the post, but I thought it was interesting to show a case in which the delay is not really needed, and how this does not really get in the way of the implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Option modules: here there is no recursion, so delay takes a particularly
</span></span></span><span style=display:flex><span><span style=color:#75715e>   simple form
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>OptionF</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>FUNCTOR</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a option<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a option
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> fmap f <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> x <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>f x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>OptionA</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>APPLICATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a option<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>OptionF</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pure x <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> x
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ap f x <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> f<span style=color:#f92672>,</span> x <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> f<span style=color:#f92672>,</span> <span style=color:#a6e22e>Some</span> x <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>f x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>OptionAlternative</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>ALTERNATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a option<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>OptionA</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> empty <span style=color:#f92672>=</span> <span style=color:#a6e22e>None</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;|&gt;)</span> o1 o2 <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> o1 <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>_</span> <span style=color:#66d9ef>as</span> res <span style=color:#f92672>-&gt;</span> res
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> o2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> delay f <span style=color:#f92672>=</span> f ()
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   A test with Option
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>OptionExample</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>OptionAlternative</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>OptAlt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Alternative_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>OptionAlternative</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>OptAlt</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Imagine looking up a database port from multiple sources: *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_env_var () <span style=color:#f92672>=</span> <span style=color:#a6e22e>None</span>           <span style=color:#75715e>(* For example the variable was not set *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_config () <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> 5432       <span style=color:#75715e>(* But is in the local config file *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> get_default () <span style=color:#f92672>=</span> <span style=color:#a6e22e>Some</span> 8080      <span style=color:#75715e>(* And we have a default value *)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* We can use OptAlt to chain fallbacks: the first `Some` wins automatically. 
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Recall from the previous blog post that `&lt;|&gt;` means
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &#34;try the left side; if it is None, fall back to the right side.&#34; *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> resolved_port <span style=color:#f92672>=</span> get_env_var () <span style=color:#f92672>&lt;|&gt;</span> get_config () <span style=color:#f92672>&lt;|&gt;</span> get_default () 
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  val resolved_port : int OptionAlternative.t = Some 5432 *)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Suppose we require three specific settings to start a server *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> required_configs <span style=color:#f92672>=[</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#e6db74>&#34;localhost&#34;</span><span style=color:#f92672>;</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#e6db74>&#34;admin&#34;</span><span style=color:#f92672>;</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#e6db74>&#34;secret_password&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* We can use sequence to encode an all or nothing scenario.
</span></span></span><span style=display:flex><span><span style=color:#75715e>  	Again, from the previous blog post `sequenceA` means
</span></span></span><span style=display:flex><span><span style=color:#75715e>  	&#34;if everything in this list is Some, give me a Some list;
</span></span></span><span style=display:flex><span><span style=color:#75715e>  	 if even one is None, fail the whole thing.&#34; *)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> test_success <span style=color:#f92672>=</span> sequenceA required_configs
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* But if even one is missing, so None, ... *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> missing_configs <span style=color:#f92672>=[</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#e6db74>&#34;localhost&#34;</span><span style=color:#f92672>;</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>None</span><span style=color:#f92672>;</span> <span style=color:#75715e>(* Missing username! *)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Some</span> <span style=color:#e6db74>&#34;secret_password&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> test_failure <span style=color:#f92672>=</span> sequenceA missing_configs
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test_opt_1 <span style=color:#f92672>=</span> OptionExample.test_success
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test_opt_2 <span style=color:#f92672>=</span> OptionExample.test_failure
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>   The new parser combinator. Here we need to use delay!
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> text <span style=color:#f92672>=</span> <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a p <span style=color:#f92672>=</span> text <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>*</span> text<span style=color:#f92672>)</span> <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>ParserApplicative</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>APPLICATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a p<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a p
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> fmap f parser <span style=color:#f92672>=</span> parser <span style=color:#f92672>&gt;.&gt;</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>c<span style=color:#f92672>,</span> cs<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>f c<span style=color:#f92672>,</span> cs<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pure c <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> input <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>[(</span>c<span style=color:#f92672>,</span> input<span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ap parser_f parser <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> input <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> parser_f input <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> []
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> cs<span style=color:#f92672>)</span> <span style=color:#f92672>::</span>[] <span style=color:#f92672>-&gt;</span> fmap f parser cs
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> lst <span style=color:#f92672>-&gt;</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>(</span>f<span style=color:#f92672>,</span> cs<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> fmap f parser cs<span style=color:#f92672>)</span> lst <span style=color:#f92672>|&gt;</span> List.concat
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>ParserAlternative</span><span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>ALTERNATIVE</span> <span style=color:#66d9ef>with</span> <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>=</span> <span style=color:#66d9ef>&#39;</span>a p<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>ParserApplicative</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> empty <span style=color:#f92672>_</span> <span style=color:#f92672>=</span>[]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#f92672>(&lt;|&gt;)</span> p1 p2 txt <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> p1 txt <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span>[] <span style=color:#f92672>-&gt;</span> p2 txt
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> res <span style=color:#f92672>-&gt;</span> res
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> delay f <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> input <span style=color:#f92672>-&gt;</span> f () input
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>ParserAlt</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Alternative_Utils</span><span style=color:#f92672>(</span><span style=color:#a6e22e>ParserAlternative</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PARSER</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> empty<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> map<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> pure<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> ap<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> delay<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span> <span style=color:#f92672>&lt;$&gt;</span> <span style=color:#f92672>):</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span> <span style=color:#f92672>&lt;*&gt;</span> <span style=color:#f92672>):</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b<span style=color:#f92672>)</span> t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span> <span style=color:#f92672>&lt;*</span> <span style=color:#f92672>):</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span> <span style=color:#f92672>*&gt;</span> <span style=color:#f92672>):</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>b t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> run<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>string</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> token<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#66d9ef>list</span><span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> fail<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> choose<span style=color:#f92672>:</span>  <span style=color:#66d9ef>&#39;</span>a t <span style=color:#66d9ef>list</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> <span style=color:#f92672>(&lt;|&gt;):</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> many<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#66d9ef>list</span> t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> some<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#66d9ef>list</span> t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> filter<span style=color:#f92672>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span><span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>a t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>Parser</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>PARSER</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>ParserAlternative</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>ParserAlt</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> map <span style=color:#f92672>=</span> fmap
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> explode s <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> aux i acc <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> 0 <span style=color:#66d9ef>then</span> acc <span style=color:#66d9ef>else</span> aux <span style=color:#f92672>(</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>s<span style=color:#f92672>.[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>::</span> acc<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>in</span> aux <span style=color:#f92672>(</span>String.length s <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span>[]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> run p s <span style=color:#f92672>=</span> explode s <span style=color:#f92672>|&gt;</span> p <span style=color:#f92672>|&gt;</span> List.map fst
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> token f <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span>[]
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> x <span style=color:#f92672>::</span> xs <span style=color:#f92672>-&gt;</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> y <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>y<span style=color:#f92672>,</span> xs<span style=color:#f92672>))</span> <span style=color:#f92672>(</span>f x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> token <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> c&#39; <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>if</span> c <span style=color:#f92672>=</span> c&#39; <span style=color:#66d9ef>then</span> <span style=color:#f92672>[</span>c<span style=color:#f92672>]</span> <span style=color:#66d9ef>else</span>[]<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> filter f p cs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> p cs <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>[(</span>x<span style=color:#f92672>,</span> cs<span style=color:#f92672>)]</span> <span style=color:#66d9ef>when</span> f x <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>[(</span>x<span style=color:#f92672>,</span>cs<span style=color:#f92672>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>[]
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>MakeCharParser</span><span style=color:#f92672>(</span><span style=color:#a6e22e>P</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>PARSER</span><span style=color:#f92672>)</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>sig</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Some optional helpers *)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> exactly<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> one_of<span style=color:#f92672>:</span>  <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>list</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> none_of<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> <span style=color:#66d9ef>list</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> range<span style=color:#f92672>:</span>   <span style=color:#66d9ef>char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> space<span style=color:#f92672>:</span>   <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> newline<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> tab<span style=color:#f92672>:</span>     <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> upper<span style=color:#f92672>:</span>   <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> lower<span style=color:#f92672>:</span>   <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> digit<span style=color:#f92672>:</span>   <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> letter<span style=color:#f92672>:</span>  <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> alpha_num<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> hex_digit<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>val</span> oct_digit<span style=color:#f92672>:</span> <span style=color:#66d9ef>char</span> P.t
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>P</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> item <span style=color:#f92672>=</span> token <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> c <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>[</span>c<span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> exactly x <span style=color:#f92672>=</span> filter <span style=color:#f92672>((=)</span> x<span style=color:#f92672>)</span> item
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> one_of l <span style=color:#f92672>=</span> filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> List.mem x l<span style=color:#f92672>)</span> item
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> none_of l <span style=color:#f92672>=</span> filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> not <span style=color:#f92672>(</span>List.mem x l<span style=color:#f92672>))</span> item
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> range l r <span style=color:#f92672>=</span> filter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> x <span style=color:#f92672>-&gt;</span> l <span style=color:#f92672>&lt;=</span> x <span style=color:#f92672>&amp;&amp;</span> x <span style=color:#f92672>&lt;=</span> r<span style=color:#f92672>)</span> item
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> space <span style=color:#f92672>=</span> one_of <span style=color:#f92672>[</span><span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;\t&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;\r&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;\n&#39;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> newline <span style=color:#f92672>=</span> exactly <span style=color:#e6db74>&#39;\n&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> tab <span style=color:#f92672>=</span> exactly <span style=color:#e6db74>&#39;\t&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> upper <span style=color:#f92672>=</span> range <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#e6db74>&#39;Z&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> lower <span style=color:#f92672>=</span> range <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#e6db74>&#39;z&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> digit <span style=color:#f92672>=</span> range <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#e6db74>&#39;9&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> letter <span style=color:#f92672>=</span> lower <span style=color:#f92672>&lt;|&gt;</span> upper
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> alpha_num <span style=color:#f92672>=</span> letter <span style=color:#f92672>&lt;|&gt;</span> digit
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> hex_digit <span style=color:#f92672>=</span> range <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#e6db74>&#39;f&#39;</span> <span style=color:#f92672>&lt;|&gt;</span> range <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#e6db74>&#39;F&#39;</span> <span style=color:#f92672>&lt;|&gt;</span> digit
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> oct_digit <span style=color:#f92672>=</span> range <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#e6db74>&#39;7&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Our first `sexp` parser
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>SexpParser</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> sexp <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Atom</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Lst</span> <span style=color:#66d9ef>of</span> sexp <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>CP</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MakeCharParser</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Parser</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>Parser</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>CP</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Parser</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>CP</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> string_of_chars <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span>String.make 1<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;.&gt;</span> String.concat <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> spaces <span style=color:#f92672>=</span> many space
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* An atom is one or more alphanumeric characters *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> atom <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> chars <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span>string_of_chars chars<span style=color:#f92672>))</span> <span style=color:#f92672>&lt;$&gt;</span> some alpha_num
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* `sexp`s are inherently recursive, so we wrap them in a delay too! *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> sexp () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> list_parser <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> elements <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Lst</span> elements<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;(&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;)&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      atom <span style=color:#f92672>&lt;|&gt;</span> list_parser
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sexp_parser <span style=color:#f92672>=</span> spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test1 <span style=color:#f92672>=</span> SexpParser.<span style=color:#f92672>(</span>run sexp_parser <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test2 <span style=color:#f92672>=</span> SexpParser.<span style=color:#f92672>(</span>run sexp_parser <span style=color:#e6db74>&#34;(foo bar baz)&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test3 <span style=color:#f92672>=</span> SexpParser.<span style=color:#f92672>(</span>run sexp_parser <span style=color:#e6db74>&#34;(foo (bar 123) baz)&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>   A `sexp` parser for dune files
</span></span></span><span style=display:flex><span><span style=color:#75715e>*)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> <span style=color:#a6e22e>DuneSexpParser</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>type</span> sexp <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Atom</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Lst</span> <span style=color:#66d9ef>of</span> sexp <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>module</span> <span style=color:#a6e22e>CP</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>MakeCharParser</span><span style=color:#f92672>(</span><span style=color:#a6e22e>Parser</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>Parser</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>include</span> <span style=color:#a6e22e>CP</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>Parser</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>open</span> <span style=color:#a6e22e>CP</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> string_of_chars <span style=color:#f92672>=</span> List.map <span style=color:#f92672>(</span>String.make 1<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;.&gt;</span> String.concat <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> spaces <span style=color:#f92672>=</span> many space
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> symbol_char <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    alpha_num <span style=color:#f92672>&lt;|&gt;</span> one_of <span style=color:#f92672>[</span><span style=color:#e6db74>&#39;_&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;-&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;.&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;/&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;:&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;*&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;+&#39;</span><span style=color:#f92672>;</span> <span style=color:#e6db74>&#39;=&#39;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> atom <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> chars <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span>string_of_chars chars<span style=color:#f92672>))</span> <span style=color:#f92672>&lt;$&gt;</span> some symbol_char
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> quoted_string <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> chars <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Atom</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>^</span> string_of_chars chars <span style=color:#f92672>^</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;&#34;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>none_of <span style=color:#f92672>[</span><span style=color:#e6db74>&#39;&#34;&#39;</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;&#34;&#39;</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> sexp () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    delay <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> list_parser <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>        <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> <span style=color:#f92672>_</span> elements <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Lst</span> elements<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;$&gt;</span> exactly <span style=color:#e6db74>&#39;(&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;*&gt;</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&lt;*&gt;</span> exactly <span style=color:#e6db74>&#39;)&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      atom <span style=color:#f92672>&lt;|&gt;</span> quoted_string <span style=color:#f92672>&lt;|&gt;</span> list_parser
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> dune_file_parser <span style=color:#f92672>=</span> many <span style=color:#f92672>(</span>spaces <span style=color:#f92672>*&gt;</span> sexp () <span style=color:#f92672>&lt;*</span> spaces<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> doi2bib_dune_content <span style=color:#f92672>=</span> <span style=color:#f92672>{|</span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>executable
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>name doi2bib<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>public_name doi2bib<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>libraries lwt lwt<span style=color:#f92672>.</span>unix cohttp<span style=color:#f92672>-</span>lwt<span style=color:#f92672>-</span>unix ezjsonm lambdasoup re cmdliner<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>flags <span style=color:#f92672>(:</span>standard <span style=color:#f92672>-</span>w <span style=color:#f92672>-</span>40<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>rule
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>targets doi2bib<span style=color:#f92672>.</span>1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>deps doi2bib<span style=color:#f92672>.</span>exe<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>(</span>action <span style=color:#f92672>(</span>run <span style=color:#f92672>./</span>doi2bib<span style=color:#f92672>.</span>exe <span style=color:#f92672>--</span>help<span style=color:#f92672>=</span>groff<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> test_parsing_dune_file <span style=color:#f92672>=</span> DuneSexpParser.<span style=color:#f92672>(</span>run dune_file_parser doi2bib_dune_content<span style=color:#f92672>)</span>
</span></span></code></pre></div></div><div class=post-footer><script src=https://utteranc.es/client.js repo=mseri/mseri.github.io issue-term=pathname label= theme=photon-dark crossorigin=anonymous async></script></div></article></main></body></html>
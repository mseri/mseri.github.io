<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Applicative on A fractal spectrum of tales</title><link>https://www.mseri.me/tags/applicative/</link><description>Recent content in Applicative on A fractal spectrum of tales</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 27 Feb 2026 11:33:16 +0100</lastBuildDate><atom:link href="https://www.mseri.me/tags/applicative/index.xml" rel="self" type="application/rss+xml"/><item><title>Fixing an infinite recursion in OCaml applicative parsers</title><link>https://www.mseri.me/fixing-an-infinite-recursion-in-ocaml-applicative-parsers/</link><pubDate>Fri, 27 Feb 2026 11:33:16 +0100</pubDate><guid>https://www.mseri.me/fixing-an-infinite-recursion-in-ocaml-applicative-parsers/</guid><description>&lt;p>Nine years ago, while I was still a fresh OCamlr, I gave a presentation (later turned blog post) with title &lt;a href="https://www.mseri.me/typeclass-ocaml/">First steps with Category Theory and OCaml&lt;/a>.
The idea was to show how to implement the basic typeclasses of Category Theory in OCaml, and how to use them to build a simple parser combinator library, by following what I had learned from Haskell.
At the time, not knowing better, I stumbled upon an annoying issue: if you look at the code examples for the &lt;code>Alternative_Utils&lt;/code> module, you will find the following commented-out code.&lt;/p></description></item><item><title>First steps with Category Theory and OCaml</title><link>https://www.mseri.me/typeclass-ocaml/</link><pubDate>Sun, 04 Jun 2017 22:00:54 +0000</pubDate><guid>https://www.mseri.me/typeclass-ocaml/</guid><description>&lt;p>Category theory is an abstract mathematical framework that had a huge influence
on pure functional programming design patterns. The abstractions and laws that
come bundled with the mathematical concepts allow us to write safer and
composable interfaces, very prone to equational reasoning, at the price of a
steeper learning curve. If you attempt to write some relatively modern Haskell
code, you will inevitably have to deal with Monoids, Functions, Monads, Lenses
and whatnot &lt;a href="https://wiki.haskell.org/Typeclassopedia" title="Typeclassopedia">typeclassopedia&lt;/a>. Also, if you are using modern OCaml libraries,
you will find fingerprints of these constructs all over the place, even though
there they are less prominent.&lt;/p></description></item></channel></rss>